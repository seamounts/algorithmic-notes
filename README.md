# ç®—æ³•å­¦ä¹ ç¬”è®°

## å¤æ‚åº¦åˆ†æ ğŸŠ

![å¤æ‚åº¦åˆ†æ](/assets/å¤æ‚åº¦åˆ†æ.svg)

### 1âƒ£ï¸ ä¸ºä»€ä¹ˆéœ€è¦å¤æ‚åº¦åˆ†æğŸ¤”ï¼Ÿ
##### äº‹åç»Ÿè®¡æ³•
å°†ä»£ç åœ¨å®é™…çš„ç¯å¢ƒè·‘ä¸€éï¼Œå¾—åˆ°è¿è¡Œçš„æ—¶é—´å’Œæ‰€éœ€è¦çš„å†…å­˜å¤§å°ã€‚

##### äº‹åç»Ÿè®¡æ³•å±€é™æ€§
1. æµ‹è¯•ç»“æœéå¸¸ä¾èµ–æµ‹è¯•ç¯å¢ƒ
2. æµ‹è¯•ç»“æœå—æµ‹è¯•æ•°æ®è§„æ¨¡å½±å“å¾ˆå¤§

å¤æ‚åº¦åˆ†æå¯ä»¥è§£å†³ä¸ç”¨ä¾èµ–å…·ä½“æµ‹è¯•æ•°æ®ã€æµ‹è¯•ç¯å¢ƒï¼Œå°±å¯ä»¥ä¼°ç®—å‡ºç®—æ³•çš„æ‰§è¡Œæ•ˆç‡ã€‚

### 2âƒ£ï¸ å¤§ O å¤æ‚åº¦è¡¨ç¤ºæ³•
æ‰€æœ‰ä»£ç çš„æ‰§è¡Œæ—¶é—´ T(n)ï¼Œä¸æ¯è¡Œä»£ç çš„æ‰§è¡Œæ¬¡æ•° n æˆæ­£æ¯”ã€‚
```
T(n) = O(f(n))
```
- T(n) è¡¨ç¤ºæ‰§è¡Œæ—¶é—´
- n è¡¨ç¤ºä»£ç æ•°æ®è§„æ¨¡
- f(n) è¡¨ç¤ºæ¯è¡Œä»£ç çš„æ‰§è¡Œæ¬¡æ•°æ€»å’Œ
- O è¡¨ç¤º T(n) å’Œ f(n) æˆæ­£æ¯”

`å¤§Oå¤æ‚åº¦`è¡¨ç¤ºä»£ç æ‰§è¡Œæ—¶é—´ä¸æ•°æ®è§„æ¨¡å¢é•¿çš„å˜åŒ–è¶‹åŠ¿ï¼Œä¹Ÿå« `æ¸è¿›æ—¶é—´å¤æ‚åº¦`

### 3âƒ£ï¸ æ—¶é—´å¤æ‚åº¦åˆ†æ
1. åªå…³æ³¨å¾ªç¯æ‰§è¡Œæ¬¡æ•°æœ€å¤šçš„ä¸€æ®µä»£ç 
2. åŠ æ³•æ³•åˆ™: æ€»å¤æ‚åº¦ç­‰äºé‡çº§æœ€å¤§çš„é‚£æ®µä»£ç çš„å¤æ‚åº¦
3. ä¹˜æ³•æ³•åˆ™: åµŒå¥—ä»£ç çš„å¤æ‚åº¦ç­‰äºåµŒå¥—å†…å¤–ä»£ç å¤æ‚åº¦çš„ä¹˜ç§¯

##### æ—¶é—´å¤æ‚åº¦åˆ†æå››ä¸ªæ¦‚å¿µ
1. æœ€å¥½æ—¶é—´å¤æ‚åº¦: ä»£ç åœ¨æœ€ç†æƒ³æƒ…å†µä¸‹æ‰§è¡Œçš„æ—¶é—´å¤æ‚åº¦
2. æœ€åæ—¶é—´å¤æ‚åº¦: ä»£ç åœ¨æœ€åæƒ…å†µä¸‹æ‰§è¡Œçš„æ—¶é—´å¤æ‚åº¦
3. å¹³å‡æ—¶é—´å¤æ‚åº¦:
4. å‡æ‘Šæ—¶é—´å¤æ‚åº¦
   æ‘Šè¿˜åˆ†ææ³•åº”ç”¨åœºæ™¯ï¼š
    1. ä»£ç åœ¨ç»å¤§å¤šæ•°æƒ…å†µä¸‹æ˜¯ä½çº§åˆ«å¤æ‚åº¦ï¼Œåªæœ‰æå°‘æ•°æƒ…å†µæ˜¯é«˜çº§åˆ«å¤æ‚åº¦
    2. ä½çº§åˆ«å’Œé«˜çº§åˆ«å¤æ‚åº¦å‡ºç°å…·æœ‰æ—¶åºè§„å¾‹ã€‚å‡æ‘Šç»“æœä¸€èˆ¬éƒ½ç­‰äºä½çº§åˆ«å¤æ‚åº¦ã€‚
   > **ä¸€èˆ¬å‡æ‘Šæ—¶é—´å¤æ‚åº¦ç­‰äºæœ€å¥½æƒ…å†µæ—¶é—´å¤æ‚åº¦**

##### ä¸ºä»€ä¹ˆå¼•å…¥å››ä¸ªå¤æ‚åº¦æ¦‚å¿µï¼Ÿ
åŒä¸€æ®µä»£ç åœ¨ä¸åŒè¾“å…¥çš„æƒ…å†µä¸‹ï¼Œå¤æ‚åº¦é‡çº§æœ‰å¯èƒ½æ˜¯ä¸ä¸€æ ·çš„ï¼Œå¼•å…¥è¿™å‡ ä¸ªæ¦‚å¿µåï¼Œå¯ä»¥æ›´åŠ å…¨é¢çš„è¡¨ç¤ºä»£ç æ‰§è¡Œæ•ˆç‡ã€‚


##### å‡ ç§å¸¸è§çš„æ—¶é—´å¤æ‚åº¦å®ä¾‹
- **å¸¸é‡é˜¶ O(1)**

  O(1)æ˜¯å¸¸é‡é˜¶æ—¶é—´å¤æ‚åº¦è¡¨ç¤ºæ–¹æ³•ï¼Œä¸€èˆ¬æƒ…å†µä¸‹ï¼Œåªè¦ä»£ç ä¸­ä¸å­˜åœ¨å¾ªç¯è¯­å¥ï¼Œé€’å½’è¯­å¥ï¼Œå…¶ä»£ç å¤æ‚åº¦å°±æ˜¯O(1)

- **å¯¹æ•°é˜¶ O(log^n^)ã€ O(nlog^n^)**

  å¯¹æ•°é˜¶æ—¶é—´å¤æ‚åº¦æ¯”è¾ƒå¸¸è§ï¼Œå¦‚å½’å¹¶æ’åºã€å¿«é€Ÿæ’åºçš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ O(nlog^n^)

- **çº¿æ€§é˜¶ O(n)**
- **å¹³æ–¹é˜¶ O(n^2^)ã€ç«‹æ–¹é˜¶ O(n^3^)ã€... kæ¬¡æ–¹é˜¶ O(n^k^)**
- **æŒ‡æ•°é˜¶ O(2^n^)**
- **é˜¶ä¹˜é˜¶ O(n!)**


### 4âƒ£ï¸ ç©ºé—´å¤æ‚åº¦åˆ†æ
è¡¨ç¤ºç®—æ³•çš„å­˜å‚¨ç©ºé—´ä¸æ•°æ®è§„æ¨¡ä¹‹é—´çš„å¢é•¿å…³ç³»ã€‚

---

## çº¿æ€§è¡¨ ğŸ‰
![çº¿æ€§è¡¨](/assets/çº¿æ€§è¡¨.svg)

### 1âƒ£ï¸ æ•°ç»„
æ•°ç»„æ˜¯ä¸€ç§çº¿æ€§è¡¨æ•°æ®ç»“æ„ã€‚ç”¨ä¸€ç»„è¿ç»­çš„å†…å­˜ç©ºé—´æ¥å­˜å‚¨å…·æœ‰ç›¸åŒç±»å‹çš„æ•°æ®ã€‚éšæœºè®¿é—®å¤æ‚åº¦ä¸ºï¼š O(1), æ’å…¥å’Œåˆ é™¤çš„æ—¶é—´å¤æ‚åº¦ä¸ºï¼š O(n)ã€‚

### 2âƒ£ï¸ é“¾è¡¨
é“¾è¡¨ç›¸å¯¹ä¸æ•°ç»„æ¥è¯´ï¼Œæ›´é€‚åˆç”¨ä¸é¢‘ç¹çš„æ’å…¥å’Œåˆ é™¤æ“ä½œçš„åœºæ™¯ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ O(1)ï¼›ä½†éšæœºè®¿é—®çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ã€‚

**å¦‚ä½•åŸºäºé“¾è¡¨å®ç° LRU ç¼“å­˜æ·˜æ±°ç®—æ³•ï¼Ÿ**

ç»´æŠ¤ä¸€ä¸ªæœ‰åºå•é“¾è¡¨ï¼Œè¶Šé è¿‘é“¾è¡¨å°¾çš„èŠ‚ç‚¹æ˜¯è¶Šæ—©ä¹‹å‰è®¿é—®çš„ï¼Œå½“æœ‰æ–°çš„æ•°æ®è¢«è®¿é—®æ—¶ï¼Œä»å¤´å¼€å§‹é¡ºåºéå†é“¾è¡¨
1. å¦‚æœæ•°æ®å·²ç»è¢«ç¼“å­˜åœ¨é“¾è¡¨äº†ï¼Œåˆ™å°†è¯¥æ•°æ®èŠ‚ç‚¹åˆ é™¤ï¼Œå¹¶é‡æ–°å°†å…¶æ’å…¥åˆ°é“¾è¡¨å¤´
2. å¦‚æœæ•°æ®æ²¡æœ‰åœ¨é“¾è¡¨ä¸­ï¼Œåˆ†ä¸ºä¸¤ç§æƒ…å†µ
    1. å¦‚æœé“¾è¡¨æœªæ»¡ï¼Œåˆ™ç›´æ¥å°†è¯¥æ•°æ®æ’å…¥åˆ°é“¾è¡¨å¤´
    2. å¦‚æœé“¾è¡¨å·²æ»¡ï¼Œåˆ™å°†é“¾è¡¨å°¾èŠ‚ç‚¹åˆ é™¤ï¼Œç„¶åå°†æ–°çš„æ•°æ®æ’å…¥é“¾è¡¨å¤´

**å¦‚ä½•è½»æ¾çš„å†™å‡ºæ­£ç¡®çš„é“¾è¡¨ä»£ç ï¼Ÿ**
- **æŠ€å·§ä¸€ï¼š ç†è§£æŒ‡é’ˆæˆ–å¼•ç”¨çš„å«ä¹‰**

  å°†æŸä¸ªå˜é‡èµ‹å€¼ç»™æŒ‡é’ˆï¼Œå®é™…ä¸Šå°±æ˜¯å°†è¿™ä¸ªå˜é‡çš„å†…å­˜åœ°å€èµ‹å€¼ç»™æŒ‡é’ˆï¼Œå¯ä»¥é€šè¿‡æŒ‡é’ˆæ‰¾åˆ°è¿™ä¸ªå˜é‡åœ¨å†…å­˜ä¸­çš„ä½ç½®ã€‚

- **æŠ€å·§äºŒï¼šè­¦æƒ•æŒ‡é’ˆä¸¢å¤±å’Œå†…å­˜æ³„éœ²**

  å°¤å…¶æ˜¯æ’å…¥èŠ‚ç‚¹çš„æ—¶å€™ï¼Œé˜²æ­¢å‡ºé”™ã€‚

- **æŠ€å·§ä¸‰ï¼š åˆ©ç”¨å“¨å…µç®€åŒ–å®ç°éš¾åº¦**

  åœ¨èŠ‚ç‚¹påæ’å…¥ä¸€ä¸ªæ–°çš„èŠ‚ç‚¹ï¼š
  ```
  new_node->next = p->next
  p->next = new_node
  ```
  å¦‚æœå‘ä¸€ä¸ªç©ºé“¾è¡¨æ’å…¥ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œåˆ™ä¸Šé¢çš„é€»è¾‘å°±ä¼šå‡ºé”™ã€‚éœ€è¦ç‰¹æ®Šå¤„ç†ï¼š
  ```
  if (head == null) {
      head = new_node
  }
  ```
  åˆ é™¤é“¾è¡¨èŠ‚ç‚¹æ“ä½œ:
  ```
  p->next == p->next->next
  ```
  å¦‚æœè¦åˆ é™¤çš„æ˜¯é“¾è¡¨æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œåˆ™ä¸Šé¢çš„åˆ é™¤æ“ä½œä¼šå‡ºé”™ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†ï¼š
  ```
  if (head->next == null) {
	  head = null
  }
  ```
  ä»å‰é¢çš„åˆ†æå¯çŸ¥ï¼Œé’ˆå¯¹é“¾è¡¨çš„æ’å…¥ã€åˆ é™¤æ“ä½œï¼Œéœ€è¦å¯¹æ’å…¥ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å’Œåˆ é™¤æœ€åä¸€ä¸ªèŠ‚ç‚¹åšç‰¹æ®Šå¤„ç†ï¼Œå¾ˆå®¹å™¨å‡ºé”™ã€‚ä¸ºäº†ç®€åŒ–ä»£ç çš„å®ç°ï¼Œéœ€è¦å¼•å…¥ *`å“¨å…µ`* ã€‚
  å¼•å…¥ *`å“¨å…µ`* ä¹‹åï¼Œä¸ç®¡é“¾è¡¨æ˜¯å¦ä¸ºç©ºï¼Œhead æŒ‡é’ˆä¸€ç›´æŒ‡å‘ *`å“¨å…µ`* èŠ‚ç‚¹ï¼Œå¯¹äºè¿™ç§æœ‰ *`å“¨å…µ`* èŠ‚ç‚¹çš„é“¾è¡¨ç§°ä¹‹ä¸º `å¸¦å¤´é“¾è¡¨`ï¼Œ åä¹‹ç§°ä¹‹ä¸º `ä¸å¸¦å¤´é“¾è¡¨`ã€‚

- **æŠ€å·§ä¸‰ï¼š é‡ç‚¹å¤„ç†è¾¹ç•Œæ¡ä»¶å¤„ç†**
    - é“¾è¡¨ä¸ºç©ºæ—¶ï¼Œä»£ç æ˜¯å¦æ­£å¸¸å·¥ä½œ
    - é“¾è¡¨åªåŒ…å«ä¸€ä¸ªèŠ‚ç‚¹æ—¶ï¼Œä»£ç æ˜¯å¦æ­£å¸¸å·¥ä½œ
    - é“¾è¡¨åªåŒ…å«ä¸¤ä¸ªèŠ‚ç‚¹æ—¶ï¼Œä»£ç æ˜¯å¦æ­£å¸¸å·¥ä½œ
    - å¤„ç†å¤´èŠ‚ç‚¹å’Œå°¾èŠ‚ç‚¹æ—¶ï¼Œä»£ç æ˜¯å¦æ­£å¸¸å·¥ä½œ

### 3âƒ£ï¸ æ ˆ

##### æ¦‚å¿µ
æ“ä½œç¬¦åˆ `å…ˆè¿›åå‡º` or `åè¿›å…ˆå‡º` çš„çº¿æ€§è¡¨ç»“æ„

æ ˆå¯ä»¥ç”¨æ•°ç»„å®ç°ï¼Œä¹Ÿå¯ä»¥ç”¨é“¾è¡¨å®ç°ã€‚ç”¨æ•°ç»„å®ç°çš„æ ˆç§°ä¹‹ä¸º `é¡ºåºæ ˆ`ï¼Œç”¨é“¾è¡¨å®ç°çš„æ ˆçš„ç§°ä¹‹ä¸º `é“¾å¼æ ˆ`ã€‚

å¦‚ä¸‹ `é¡ºåºæ ˆ` çš„å®ç°å®ä¾‹ (åŸºäºgoå®ç°)ï¼š
```go
// åŸºäºæ•°ç»„å®ç°çš„é¡ºåºæ ˆ
type Stack interface {
  Push(string) bool
  Pop() string
}

type OrderStack struct {
  items [10]string
  count int
}

// å…¥æ ˆ
func (os *OrderStack) Push(item string) bool {
  if os.count == len(os.items) {
    return false
  }
  os.items[os.count] = item 
  os.count++
  return true
}

// å‡ºæ ˆ
func (os *OrderStack) Pop() string {
  if os.count == 0 {
    return ""
  }
  item := os.items[os.count-1]
  os.count--
  return item
}
```

##### æ ˆçš„åº”ç”¨

- å‡½æ•°è°ƒç”¨æ ˆ

- è¡¨è¾¾å¼æ±‚å€¼
  <img src="assets/è¡¨è¾¾å¼æ±‚å€¼.jpg" width="500" hegiht="300" />

    - [ä»£ç å®ç°](doc/expression_eval/expression_eval.go)

- æ‹¬å·åŒ¹é…
  ä¾æ¬¡æ‰«æï¼Œå°†å·¦æ‹¬å·æ”¾å…¥æ ˆä¸­ï¼Œé‡åˆ°å³æ‹¬å·åˆ™ä»æ ˆé¡¶å–å‡ºä¸€ä¸ªå·¦æ‹¬å·ï¼Œå¦‚æœåŒ¹é…åˆ™ç»§ç»­æ‰«æï¼Œå¦‚æœæ‰«æä¸­ä¸èƒ½åŒ¹é…æˆ–è€…æ ˆä¸­æœ‰å‰©ä½™æ•°æ®ï¼Œåˆ™è¯´æ˜ä¸ºéæ³•æ ¼å¼ã€‚
    - [ä»£ç å®ç°](doc/parenthesis_match/parenthesis_match.go)


### 4âƒ£ï¸ é˜Ÿåˆ—

---

## æ’åºç®—æ³• ğŸŒ

![æ’åºç®—æ³•](assets/æ’åºç®—æ³•.svg)

**å†’æ³¡æ’åº**


å‚è€ƒä»£ç å®ç°ï¼š
```go
func BubbleSort(datas []int) []int {
    for i := 0; i < len(datas)-1; i++ {
        for j := 0; j < len(datas)-1-i; j++ {
            if datas[j] > datas[j+1] {
                tmp := datas[j]
                datas[j] = datas[j+1]
                datas[j+1] = tmp
            }
        }
    }
    return datas
}
```

**æ’å…¥æ’åº**

```go
func InsertSort(datas []int) []int {
    for i := 1; i < len(datas); i++ {
        if datas[i] >= datas[i-1] {
            continue
        }
        for j := 0; j < i; j++ {
            if datas[i] < datas[j] {
                tmp := datas[i]
                k := i
                for {
                    if k == j {
                        break
                    }
                    datas[k] = datas[k-1]
                    k = k - 1
                }
                datas[j] = tmp
                break
            }
        }
    }
    return datas
}

```

**é€‰æ‹©æ’åº**

```go
func SelectSort(datas []int) []int {
    for i := 0; i < len(datas)-1; i++ {
        minIndex := i
        for j := i + 1; j < len(datas); j++ {
            if datas[minIndex] > datas[j] {
                minIndex = j
            }
        }
        tmp := datas[i]
        datas[i] = datas[minIndex]
        datas[minIndex] = tmp
    }
    return datas
}
```

**å½’å¹¶æ’åº**

```go
func MergeSort(datas []int) []int {
	if len(datas) == 1 {
		return datas
	}
	left := MergeSort(datas[0 : len(datas)/2])
	right := MergeSort(datas[len(datas)/2 : len(datas)])

	return Merge(left, right)
}

func Merge(left, right []int) []int {
	leftLen := len(left)
	rightLen := len(right)
	sortDatas := make([]int, 0, leftLen+rightLen)

	i := 0
	j := 0

	for {
		if i == leftLen && j == rightLen {
			break
		}
		if i == leftLen {
			sortDatas = append(sortDatas, right[j:rightLen]...)
			break
		}
		if j == rightLen {
			sortDatas = append(sortDatas, left[i:leftLen]...)
			break
		}

		if left[i] < right[j] {
			sortDatas = append(sortDatas, left[i])
			i++
		} else {
			sortDatas = append(sortDatas, right[j])
			j++
		}
	}
	return sortDatas
}
```

**å¿«é€Ÿæ’åº**

```go
func QuickSort(datas []int) []int {
    QuickSort_C(datas, 0, len(datas)-1)
    return datas
}

func QuickSort_C(datas []int, p, r int) {
    if p >= r {
        return
    }
    pivot := datas[r]
    i := p
    for j := p; j < r; j++ {
        if datas[j] < pivot {
            tmp := datas[j]
            datas[j] = datas[i]
            datas[i] = tmp
            i++
        }
    }
    tmp := datas[i]
    datas[i] = datas[r]
    datas[r] = tmp

    QuickSort_C(datas, 0, i-1)
    QuickSort_C(datas, i+1, r)
}
```

---

## æ•£åˆ—è¡¨ ğŸ

![](assets/æ•£åˆ—è¡¨.svg)


---
## æ ‘ ğŸŒ²

![](assets/æ ‘.svg)





